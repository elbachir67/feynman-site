<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NumPy | IA4Ndada</title>

    <!-- Pyodide pour Python dans le navigateur -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>

    <link rel="stylesheet" href="../../styles/module.css" />
  </head>
  <body>
    <!-- Navigation -->
    <nav class="nav">
      <div class="nav-container">
        <div class="nav-breadcrumb">
          <a href="../../index.html">üè† Accueil</a>
          <span>‚Ä∫</span>
          <span>üíª Python</span>
          <span>‚Ä∫</span>
          <span>NumPy</span>
        </div>
        <div class="progress-indicator">
          <span id="progress-text">Progression: 0%</span>
          <div class="progress-bar">
            <div
              class="progress-fill"
              id="progress-fill"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>
    </nav>

    <!-- Contenu principal -->
    <div class="container">
      <h1>üî¢ NumPy : Calcul Num√©rique</h1>
      <p class="subtitle">Module 2.2 - Programmation pour l'IA</p>

      <!-- Objectifs -->
      <div class="objectives">
        <h2>üéØ Objectifs d'apprentissage</h2>
        <ul id="objectives-list">
          <!-- Les objectifs seront ajout√©s dynamiquement -->
        </ul>
      </div>

      <!-- Contenu du module -->
      <div id="module-content">
        <!-- Le contenu sera ajout√© dynamiquement -->
      </div>

      <!-- Quiz -->
      <div class="quiz" id="module-quiz" style="display: none">
        <div class="quiz-question" id="quiz-question"></div>
        <div class="quiz-options" id="quiz-options"></div>
        <div class="quiz-feedback" id="quiz-feedback"></div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint">
        <h3>üéâ Checkpoint - NumPy</h3>
        <p>
          F√©licitations ! Vous ma√Ætrisez maintenant NumPy pour les calculs
          num√©riques en IA.
        </p>
        <button
          class="checkpoint-btn"
          id="checkpoint-btn"
          onclick="completeCheckpoint()"
        >
          Marquer comme compl√©t√©
        </button>
      </div>

      <!-- Navigation entre modules -->
      <div class="module-nav">
        <a href="basics.html" class="nav-link" id="prev-link"
          >‚Üê Module pr√©c√©dent : Python Bases</a
        >
        <a href="pandas.html" class="nav-link" id="next-link"
          >Module suivant : Pandas ‚Üí</a
        >
      </div>
    </div>

    <script src="../../scripts/module-engine.js"></script>
    <script>
      // Configuration du module NumPy
      const moduleConfig = {
        id: "python-numpy",
        title: "NumPy : Calcul Num√©rique",
        category: "Python",
        objectives: [
          "Comprendre pourquoi NumPy est essentiel pour l'IA",
          "Cr√©er et manipuler des arrays NumPy efficacement",
          "Ma√Ætriser les op√©rations vectorielles et matricielles",
          "Appliquer NumPy aux probl√®mes concrets d'IA",
        ],
        content: [
          {
            type: "concept",
            icon: "üí°",
            title: "Pourquoi NumPy r√©volutionne l'IA ?",
            content: `
                        <p><strong>NumPy</strong> (Numerical Python) est la fondation de tout l'√©cosyst√®me IA en Python. Sans NumPy, pas de Pandas, pas de scikit-learn, pas de TensorFlow !</p>
                        
                        <p><strong>üîë Probl√®me r√©solu :</strong></p>
                        <ul>
                            <li>üìä <strong>Listes Python</strong> : lentes pour les gros calculs</li>
                            <li>‚ö° <strong>Arrays NumPy</strong> : jusqu'√† 100x plus rapides !</li>
                        </ul>
                        
                        <p><strong>üöÄ Avantages NumPy :</strong></p>
                        <ul>
                            <li>‚ö° <strong>Performance</strong> : code optimis√© en C</li>
                            <li>üßÆ <strong>Vectorisation</strong> : op√©rations sur des arrays entiers</li>
                            <li>üìê <strong>Broadcasting</strong> : op√©rations entre arrays de tailles diff√©rentes</li>
                            <li>üîó <strong>Int√©gration</strong> : base de tout l'√©cosyst√®me scientifique</li>
                        </ul>
                        
                        <p><strong>ü§ñ Applications en IA :</strong></p>
                        <ul>
                            <li>üñºÔ∏è <strong>Images</strong> : matrices de pixels</li>
                            <li>üìä <strong>Datasets</strong> : tableaux de donn√©es</li>
                            <li>üß† <strong>R√©seaux de neurones</strong> : matrices de poids</li>
                            <li>üìà <strong>Calculs math√©matiques</strong> : alg√®bre lin√©aire rapide</li>
                        </ul>
                    `,
          },
          {
            type: "intuition",
            icon: "üß†",
            title: "Liste Python vs Array NumPy",
            content: `
                        <p>Imaginez que vous devez <strong>additionner 1 million de nombres</strong> :</p>
                        
                        <p><strong>üêå Avec des listes Python :</strong></p>
                        <ul>
                            <li>Python parcourt chaque √©l√©ment un par un</li>
                            <li>V√©rifie le type de chaque nombre</li>
                            <li>Fait l'addition en Python pur</li>
                            <li><strong>R√©sultat :</strong> 1 seconde ‚è±Ô∏è</li>
                        </ul>
                        
                        <p><strong>‚ö° Avec des arrays NumPy :</strong></p>
                        <ul>
                            <li>NumPy sait que tous les √©l√©ments sont des nombres</li>
                            <li>Utilise du code C optimis√©</li>
                            <li>Traite plusieurs √©l√©ments simultan√©ment</li>
                            <li><strong>R√©sultat :</strong> 0.01 seconde ‚ö°</li>
                        </ul>
                        
                        <p><strong>üí° Analogie :</strong></p>
                        <p>C'est comme la diff√©rence entre :</p>
                        <ul>
                            <li>üö∂ <strong>Marcher</strong> (listes Python) : flexible mais lent</li>
                            <li>üöÑ <strong>TGV</strong> (arrays NumPy) : rapide sur des rails optimis√©s</li>
                        </ul>
                    `,
          },
          {
            type: "code",
            title: "Cr√©ation d'arrays de base",
            description: "Cr√©ons nos premiers arrays NumPy :",
            code: `import numpy as np

# Cr√©ation √† partir d'une liste
liste_python = [1, 2, 3, 4, 5]
array_numpy = np.array(liste_python)

print("Liste Python:", liste_python)
print("Array NumPy:", array_numpy)
print("Type:", type(array_numpy))
print("Forme:", array_numpy.shape)`,
          },
          {
            type: "code",
            title: "Arrays 2D (matrices)",
            description: "Cr√©ons des matrices avec NumPy :",
            code: `# Matrice 2D
matrice = np.array([[1, 2, 3], 
                    [4, 5, 6]])
print("Matrice 2D:")
print(matrice)
print("Forme (lignes, colonnes):", matrice.shape)
print("Nombre de dimensions:", matrice.ndim)
print("Nombre total d'√©l√©ments:", matrice.size)`,
          },
          {
            type: "code",
            title: "Arrays sp√©ciaux",
            description:
              "NumPy offre des fonctions pour cr√©er des arrays sp√©ciaux :",
            code: `# Arrays sp√©ciaux
zeros = np.zeros(5)
ones = np.ones((3, 4))
identite = np.eye(3)
aleatoire = np.random.random((2, 3))

print("Z√©ros:", zeros)
print("\\nOnes:\\n", ones)
print("\\nIdentit√©:\\n", identite)
print("\\nAl√©atoire:\\n", aleatoire.round(2))`,
          },
          {
            type: "code",
            title: "S√©quences et ranges",
            description: "Cr√©ons des s√©quences de nombres :",
            code: `# S√©quences
sequence = np.arange(0, 10, 2)  # De 0 √† 10, pas de 2
lineaire = np.linspace(0, 1, 5)  # 5 points entre 0 et 1
logspace = np.logspace(0, 2, 5)  # 5 points en √©chelle log

print("Arange (0 √† 10, pas de 2):", sequence)
print("Linspace (5 points 0-1):", lineaire)
print("Logspace (√©chelle log):", logspace.round(1))`,
          },
          {
            type: "code",
            title: "Op√©rations vectorielles de base",
            description: "Les op√©rations sur les arrays sont vectoris√©es :",
            code: `# Op√©rations vectorielles
a = np.array([1, 2, 3, 4])
b = np.array([10, 20, 30, 40])

print("a =", a)
print("b =", b)
print("\\nOp√©rations vectorielles:")
print("a + b =", a + b)
print("a * b =", a * b)
print("a ** 2 =", a ** 2)`,
          },
          {
            type: "code",
            title: "Op√©rations avec scalaires",
            description:
              "NumPy applique automatiquement les op√©rations avec des scalaires :",
            code: `# Op√©rations avec scalaires
arr = np.array([1, 2, 3, 4, 5])

print("Array original:", arr)
print("Multiplier par 2:", arr * 2)
print("Ajouter 10:", arr + 10)
print("Puissance 2:", arr ** 2)
print("Racine carr√©e:", np.sqrt(arr))`,
          },
          {
            type: "code",
            title: "Fonctions math√©matiques",
            description: "NumPy inclut de nombreuses fonctions math√©matiques :",
            code: `# Fonctions math√©matiques
donnees = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

print("Donn√©es:", donnees)
print("Somme:", np.sum(donnees))
print("Moyenne:", np.mean(donnees))
print("M√©diane:", np.median(donnees))
print("√âcart-type:", np.std(donnees))
print("Min/Max:", np.min(donnees), "/", np.max(donnees))`,
          },
          {
            type: "code",
            title: "Indexation de base",
            description: "Acc√©dons aux √©l√©ments des arrays :",
            code: `# Array 2D pour les exemples
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

print("Matrice originale:")
print(matrice)
print("\\nIndexation:")
print("√âl√©ment [0,0]:", matrice[0, 0])
print("√âl√©ment [1,2]:", matrice[1, 2])
print("Derni√®re ligne:", matrice[-1])`,
          },
          {
            type: "code",
            title: "Slicing avanc√©",
            description: "Extrayons des sous-parties des arrays :",
            code: `print("Slicing:")
print("2 premi√®res lignes:\\n", matrice[:2])
print("\\n2 derni√®res colonnes:\\n", matrice[:, -2:])
print("\\nSous-matrice [1:3, 1:3]:\\n", matrice[1:3, 1:3])`,
          },
          {
            type: "code",
            title: "Indexation bool√©enne",
            description: "Filtrons les donn√©es avec des conditions :",
            code: `# Indexation bool√©enne (tr√®s puissant !)
condition = matrice > 6
print("Indexation bool√©enne:")
print("√âl√©ments > 6:", condition)
print("Valeurs > 6:", matrice[condition])

# Modification avec indexation bool√©enne
matrice_copie = matrice.copy()
matrice_copie[matrice_copie > 8] = 99
print("\\nApr√®s modification (>8 ‚Üí 99):")
print(matrice_copie)`,
          },
          {
            type: "code",
            title: "Broadcasting : concept",
            description:
              "Le broadcasting permet d'op√©rer sur des arrays de tailles diff√©rentes :",
            code: `# Broadcasting avec donn√©es s√©n√©galaises
ventes_dakar = np.array([150000, 200000, 180000])  # Ventes en FCFA
bonus = 25000  # Bonus en FCFA

resultat = ventes_dakar + bonus
print("Broadcasting scalaire:")
print(f"Ventes + Bonus = {resultat} FCFA")

# Broadcasting avec arrays
ventes_regions = np.array([[150000, 200000, 180000],  # Dakar
                          [120000, 160000, 140000]])  # Thi√®s
bonus_produits = np.array([25000, 30000, 20000])  # Bonus par produit

resultat = ventes_regions + bonus_produits
print("\\nBroadcasting array:")
print("Ventes + Bonus par produit (FCFA):")
print(resultat)`,
          },
          {
            type: "code",
            title: "Broadcasting : applications",
            description: "Applications pratiques du broadcasting :",
            code: `# Normalisation des ventes par r√©gion
ventes_mensuelles = np.array([[450000, 380000, 520000],  # Dakar
                             [320000, 280000, 350000],  # Thi√®s  
                             [280000, 240000, 300000]], dtype=float)  # Kaolack

# Calculer la moyenne de chaque colonne
moyennes_produits = np.mean(ventes_mensuelles, axis=0)
print("Ventes par r√©gion (FCFA):")
print(ventes_mensuelles)
print("Moyennes par produit:", moyennes_produits.astype(int))

# Centrer les donn√©es (broadcasting automatique)
ventes_centrees = ventes_mensuelles - moyennes_produits
print("\\n√âcarts √† la moyenne par r√©gion:")
print(ventes_centrees.astype(int))`,
          },
          {
            type: "code",
            title: "Broadcasting complexe",
            description: "Broadcasting avec des dimensions multiples :",
            code: `# Calcul de commissions par vendeur et r√©gion
vendeurs = np.array([[5], [8], [12]])  # Nb ventes par vendeur (3x1)
taux_commission = np.array([0.05, 0.08])  # Taux par r√©gion (2,)

print("Calcul des commissions:")
print("Ventes par vendeur:\\n", vendeurs)
print("Taux par r√©gion:", taux_commission)
commissions = vendeurs * taux_commission * 100000  # Base 100k FCFA
print("Commissions (FCFA):\\n", commissions.astype(int))

# Prix par quantit√© et remise
prix_unitaire = np.arange(50000, 300000, 50000).reshape(5, 1)  # Prix FCFA
remises = np.array([0.9, 0.85, 0.8])  # Remises par volume
prix_finaux = prix_unitaire * remises
print("\\nPrix avec remises (FCFA):")
print(prix_finaux.astype(int))`,
          },
          {
            type: "code",
            title: "Matrices et vecteurs",
            description: "Op√©rations d'alg√®bre lin√©aire de base :",
            code: `# Matrices de transformation pour donn√©es g√©ographiques
# Matrice de rotation pour coordonn√©es GPS S√©n√©gal
rotation_gps = np.array([[0.9, -0.1], 
                        [0.1,  0.9]])

# Matrice de donn√©es √©conomiques
donnees_eco = np.array([[450000, 380000],  # PIB Dakar-Thi√®s
                       [320000, 280000]])  # PIB Kaolack-Ziguinchor

# Vecteur de croissance
croissance = np.array([1.05, 1.08])  # +5% et +8%

print("üåç Matrice rotation GPS:")
print(rotation_gps)
print("\\nüí∞ Donn√©es √©conomiques (FCFA):")
print(donnees_eco)
print("\\nüìà Vecteur croissance:", croissance)`,
          },
          {
            type: "code",
            title: "Produits matriciels",
            description: "Calculons des produits matriciels :",
            code: `# Calculs √©conomiques matriciels
print("Op√©rations matricielles:")
print("Somme des donn√©es √©conomiques:")
print(donnees_eco + rotation_gps * 100000)

print("\\nProjection √©conomique (matrice @ donn√©es):")
projection = rotation_gps @ donnees_eco
print(projection.astype(int))

print("\\nCroissance appliqu√©e:")
croissance_appliquee = donnees_eco @ croissance
print(croissance_appliquee.astype(int), "FCFA")`,
          },
          {
            type: "code",
            title: "Op√©rations avanc√©es",
            description: "Op√©rations d'alg√®bre lin√©aire avanc√©es :",
            code: `# Analyse avanc√©e des donn√©es √©conomiques
print("üìä Analyse matricielle avanc√©e:")
print("D√©terminant (stabilit√©):", round(np.linalg.det(donnees_eco), 2))
print("Trace (somme diagonale):", np.trace(donnees_eco))

# Transpos√©e pour changer perspective
print("\\nüîÑ Transpos√©e (r√©gions ‚Üí secteurs):")
print(donnees_eco.T)

# Inverse (si elle existe)
try:
    eco_inv = np.linalg.inv(donnees_eco)
    print("\\n‚Ü©Ô∏è Matrice inverse:")
    print(eco_inv.round(8))
    print("\\n‚úÖ V√©rification (doit √™tre identit√©):")
    print((donnees_eco @ eco_inv).round(2))
except:
    print("\\n‚ùå Matrice √©conomique non inversible")`,
          },
        ],
        quiz: {
          question:
            "ü§î Quelle est la principale diff√©rence entre une liste Python et un array NumPy ?",
          options: [
            "A) Les arrays sont plus lents",
            "B) Les arrays ne peuvent contenir qu'un seul type de donn√©es",
            "C) Les listes sont plus flexibles",
            "D) Il n'y a pas de diff√©rence",
          ],
          correct: 1,
          explanation:
            "Les arrays NumPy ne peuvent contenir qu'un seul type de donn√©es (homog√®nes), ce qui permet des optimisations importantes et des calculs vectoris√©s ultra-rapides.",
        },
        prevModule: "basics.html",
        nextModule: "pandas.html",
      };

      // Initialiser le module
      document.addEventListener("DOMContentLoaded", function () {
        initializeModule(moduleConfig);
      });
    </script>
  </body>
</html>
