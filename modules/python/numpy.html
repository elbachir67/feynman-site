<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NumPy | IA4Ndada</title>

    <!-- Pyodide pour Python dans le navigateur -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>

    <link rel="stylesheet" href="../../styles/module.css" />
  </head>
  <body>
    <!-- Navigation -->
    <nav class="nav">
      <div class="nav-container">
        <div class="nav-breadcrumb">
          <a href="../../index.html">ğŸ  Accueil</a>
          <span>â€º</span>
          <span>ğŸ’» Python</span>
          <span>â€º</span>
          <span>NumPy</span>
        </div>
        <div class="progress-indicator">
          <span id="progress-text">Progression: 0%</span>
          <div class="progress-bar">
            <div
              class="progress-fill"
              id="progress-fill"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>
    </nav>

    <!-- Contenu principal -->
    <div class="container">
      <h1>ğŸ”¢ NumPy : Calcul NumÃ©rique</h1>
      <p class="subtitle">Module 2.2 - Programmation pour l'IA</p>

      <!-- Objectifs -->
      <div class="objectives">
        <h2>ğŸ¯ Objectifs d'apprentissage</h2>
        <ul id="objectives-list">
          <!-- Les objectifs seront ajoutÃ©s dynamiquement -->
        </ul>
      </div>

      <!-- Contenu du module -->
      <div id="module-content">
        <!-- Le contenu sera ajoutÃ© dynamiquement -->
      </div>

      <!-- Quiz -->
      <div class="quiz" id="module-quiz" style="display: none">
        <div class="quiz-question" id="quiz-question"></div>
        <div class="quiz-options" id="quiz-options"></div>
        <div class="quiz-feedback" id="quiz-feedback"></div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint">
        <h3>ğŸ‰ Checkpoint - NumPy</h3>
        <p>
          FÃ©licitations ! Vous maÃ®trisez maintenant NumPy pour les calculs
          numÃ©riques en IA.
        </p>
        <button
          class="checkpoint-btn"
          id="checkpoint-btn"
          onclick="completeCheckpoint()"
        >
          Marquer comme complÃ©tÃ©
        </button>
      </div>

      <!-- Navigation entre modules -->
      <div class="module-nav">
        <a href="basics.html" class="nav-link" id="prev-link"
          >â† Module prÃ©cÃ©dent : Python Bases</a
        >
        <a href="pandas.html" class="nav-link" id="next-link"
          >Module suivant : Pandas â†’</a
        >
      </div>
    </div>

    <script src="../../scripts/module-engine.js"></script>
    <script>
      // Configuration du module NumPy
      const moduleConfig = {
        id: "python-numpy",
        title: "NumPy : Calcul NumÃ©rique",
        category: "Python",
        objectives: [
          "Comprendre pourquoi NumPy est essentiel pour l'IA",
          "CrÃ©er et manipuler des arrays NumPy efficacement",
          "MaÃ®triser les opÃ©rations vectorielles et matricielles",
          "Appliquer NumPy aux problÃ¨mes concrets d'IA",
        ],
        content: [
          {
            type: "concept",
            icon: "ğŸ’¡",
            title: "Pourquoi NumPy rÃ©volutionne l'IA ?",
            content: `
                        <p><strong>NumPy</strong> (Numerical Python) est la fondation de tout l'Ã©cosystÃ¨me IA en Python. Sans NumPy, pas de Pandas, pas de scikit-learn, pas de TensorFlow !</p>
                        
                        <p><strong>ğŸ”‘ ProblÃ¨me rÃ©solu :</strong></p>
                        <ul>
                            <li>ğŸ“Š <strong>Listes Python</strong> : lentes pour les gros calculs</li>
                            <li>âš¡ <strong>Arrays NumPy</strong> : jusqu'Ã  100x plus rapides !</li>
                        </ul>
                        
                        <p><strong>ğŸš€ Avantages NumPy :</strong></p>
                        <ul>
                            <li>âš¡ <strong>Performance</strong> : code optimisÃ© en C</li>
                            <li>ğŸ§® <strong>Vectorisation</strong> : opÃ©rations sur des arrays entiers</li>
                            <li>ğŸ“ <strong>Broadcasting</strong> : opÃ©rations entre arrays de tailles diffÃ©rentes</li>
                            <li>ğŸ”— <strong>IntÃ©gration</strong> : base de tout l'Ã©cosystÃ¨me scientifique</li>
                        </ul>
                        
                        <p><strong>ğŸ¤– Applications en IA :</strong></p>
                        <ul>
                            <li>ğŸ–¼ï¸ <strong>Images</strong> : matrices de pixels</li>
                            <li>ğŸ“Š <strong>Datasets</strong> : tableaux de donnÃ©es</li>
                            <li>ğŸ§  <strong>RÃ©seaux de neurones</strong> : matrices de poids</li>
                            <li>ğŸ“ˆ <strong>Calculs mathÃ©matiques</strong> : algÃ¨bre linÃ©aire rapide</li>
                        </ul>
                    `,
          },
          {
            type: "intuition",
            icon: "ğŸ§ ",
            title: "Liste Python vs Array NumPy",
            content: `
                        <p>Imaginez que vous devez <strong>additionner 1 million de nombres</strong> :</p>
                        
                        <p><strong>ğŸŒ Avec des listes Python :</strong></p>
                        <ul>
                            <li>Python parcourt chaque Ã©lÃ©ment un par un</li>
                            <li>VÃ©rifie le type de chaque nombre</li>
                            <li>Fait l'addition en Python pur</li>
                            <li><strong>RÃ©sultat :</strong> 1 seconde â±ï¸</li>
                        </ul>
                        
                        <p><strong>âš¡ Avec des arrays NumPy :</strong></p>
                        <ul>
                            <li>NumPy sait que tous les Ã©lÃ©ments sont des nombres</li>
                            <li>Utilise du code C optimisÃ©</li>
                            <li>Traite plusieurs Ã©lÃ©ments simultanÃ©ment</li>
                            <li><strong>RÃ©sultat :</strong> 0.01 seconde âš¡</li>
                        </ul>
                        
                        <p><strong>ğŸ’¡ Analogie :</strong></p>
                        <p>C'est comme la diffÃ©rence entre :</p>
                        <ul>
                            <li>ğŸš¶ <strong>Marcher</strong> (listes Python) : flexible mais lent</li>
                            <li>ğŸš„ <strong>TGV</strong> (arrays NumPy) : rapide sur des rails optimisÃ©s</li>
                        </ul>
                    `,
          },
          {
            type: "code",
            title: "CrÃ©ation d'arrays NumPy",
            description:
              "DÃ©couvrons les diffÃ©rentes faÃ§ons de crÃ©er des arrays :",
            code: `import numpy as np

# CrÃ©ation Ã  partir d'une liste
liste_python = [1, 2, 3, 4, 5]
array_numpy = np.array(liste_python)

print("Liste Python:", liste_python)
print("Array NumPy:", array_numpy)
print("Type:", type(array_numpy))

# Arrays 2D (matrices)
matrice = np.array([[1, 2, 3], 
                    [4, 5, 6]])
print("\\nMatrice 2D:")
print(matrice)
print("Forme (shape):", matrice.shape)  # (lignes, colonnes)

# CrÃ©ation d'arrays spÃ©ciaux
zeros = np.zeros(5)  # Array de zÃ©ros
ones = np.ones((3, 4))  # Matrice de uns
identite = np.eye(3)  # Matrice identitÃ©
aleatoire = np.random.random((2, 3))  # Nombres alÃ©atoires

print("\\nArrays spÃ©ciaux:")
print("ZÃ©ros:", zeros)
print("Ones:\\n", ones)
print("IdentitÃ©:\\n", identite)
print("AlÃ©atoire:\\n", aleatoire)

# SÃ©quences
sequence = np.arange(0, 10, 2)  # De 0 Ã  10, pas de 2
lineaire = np.linspace(0, 1, 5)  # 5 points entre 0 et 1

print("\\nSÃ©quences:")
print("Arange:", sequence)
print("Linspace:", lineaire)`,
          },
          {
            type: "code",
            title: "OpÃ©rations vectorielles",
            description:
              "La puissance de NumPy : opÃ©rations sur des arrays entiers :",
            code: `import numpy as np

# CrÃ©ation d'arrays
a = np.array([1, 2, 3, 4, 5])
b = np.array([10, 20, 30, 40, 50])

print("Array a:", a)
print("Array b:", b)

# OpÃ©rations Ã©lÃ©ment par Ã©lÃ©ment (vectorisÃ©es)
addition = a + b
multiplication = a * b
puissance = a ** 2
racine = np.sqrt(a)

print("\\nOpÃ©rations vectorisÃ©es:")
print("a + b =", addition)
print("a * b =", multiplication)
print("aÂ² =", puissance)
print("âˆša =", racine)

# OpÃ©rations avec des scalaires
scalaire = a + 10  # Ajoute 10 Ã  chaque Ã©lÃ©ment
print("\\na + 10 =", scalaire)

# Fonctions mathÃ©matiques
angles = np.array([0, np.pi/4, np.pi/2, np.pi])
sinus = np.sin(angles)
cosinus = np.cos(angles)

print("\\nFonctions trigonomÃ©triques:")
print("Angles:", angles)
print("Sin:", sinus)
print("Cos:", cosinus)

# Statistiques
donnees = np.array([12, 15, 18, 14, 16, 13, 17])
print("\\nStatistiques:")
print("DonnÃ©es:", donnees)
print("Moyenne:", np.mean(donnees))
print("MÃ©diane:", np.median(donnees))
print("Ã‰cart-type:", np.std(donnees))
print("Min/Max:", np.min(donnees), "/", np.max(donnees))`,
          },
          {
            type: "code",
            title: "Indexation et slicing avancÃ©s",
            description: "AccÃ©der et modifier les donnÃ©es efficacement :",
            code: `import numpy as np

# Array 2D pour les exemples
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

print("Matrice originale:")
print(matrice)

# Indexation de base
print("\\nIndexation:")
print("Ã‰lÃ©ment [0,0]:", matrice[0, 0])
print("Ã‰lÃ©ment [1,2]:", matrice[1, 2])
print("DerniÃ¨re ligne:", matrice[-1])
print("DerniÃ¨re colonne:", matrice[:, -1])

# Slicing
print("\\nSlicing:")
print("2 premiÃ¨res lignes:\\n", matrice[:2])
print("2 derniÃ¨res colonnes:\\n", matrice[:, -2:])
print("Sous-matrice [1:3, 1:3]:\\n", matrice[1:3, 1:3])

# Indexation boolÃ©enne (trÃ¨s puissant !)
condition = matrice > 6
print("\\nIndexation boolÃ©enne:")
print("Ã‰lÃ©ments > 6:", condition)
print("Valeurs > 6:", matrice[condition])

# Modification avec indexation boolÃ©enne
matrice_copie = matrice.copy()
matrice_copie[matrice_copie > 8] = 99
print("\\nAprÃ¨s modification (>8 â†’ 99):")
print(matrice_copie)

# Indexation avec des arrays
indices_lignes = np.array([0, 2])
indices_colonnes = np.array([1, 3])
print("\\nIndexation avec arrays:")
print("Lignes 0 et 2:", matrice[indices_lignes])
print("Ã‰lÃ©ments [0,1] et [2,3]:", matrice[indices_lignes, indices_colonnes])`,
          },
          {
            type: "mathematique",
            icon: "âˆ‘",
            title: "Broadcasting : la magie NumPy",
            content: `
                        <p>Le <strong>broadcasting</strong> permet d'effectuer des opÃ©rations entre arrays de tailles diffÃ©rentes. C'est l'une des fonctionnalitÃ©s les plus puissantes de NumPy !</p>
                        
                        <p><strong>ğŸ”‘ RÃ¨gles du broadcasting :</strong></p>
                        <ol>
                            <li>NumPy compare les dimensions de droite Ã  gauche</li>
                            <li>Les dimensions sont compatibles si elles sont Ã©gales ou si l'une vaut 1</li>
                            <li>Les dimensions manquantes sont considÃ©rÃ©es comme 1</li>
                        </ol>
                        
                        <p><strong>ğŸ“ Exemples de compatibilitÃ© :</strong></p>
                        <ul style="list-style: none; padding-left: 0">
                            <li><strong>â€¢ (3, 4) + (4,)</strong> â†’ âœ… Compatible</li>
                            <li><strong>â€¢ (3, 4) + (3, 1)</strong> â†’ âœ… Compatible</li>
                            <li><strong>â€¢ (3, 4) + (2, 4)</strong> â†’ âŒ Incompatible</li>
                        </ul>
                        
                        <p><strong>ğŸ¯ Applications pratiques :</strong></p>
                        <ul>
                            <li>ğŸ“Š <strong>Normalisation</strong> : soustraire la moyenne de chaque colonne</li>
                            <li>ğŸ–¼ï¸ <strong>Traitement d'images</strong> : appliquer un filtre Ã  tous les pixels</li>
                            <li>ğŸ§  <strong>RÃ©seaux de neurones</strong> : ajouter un biais Ã  chaque neurone</li>
                        </ul>
                        
                        <p><strong>ğŸ’¡ Avantage :</strong> Pas besoin de boucles explicites, NumPy gÃ¨re tout automatiquement !</p>
                    `,
          },
          {
            type: "code",
            title: "Broadcasting en action",
            description: "Voyons le broadcasting Ã  l'Å“uvre :",
            code: `import numpy as np

# Exemple 1: Array 2D + Array 1D
matrice = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])

vecteur = np.array([10, 20, 30])

print("Matrice (3x3):")
print(matrice)
print("\\nVecteur (3,):")
print(vecteur)

# Broadcasting: ajoute le vecteur Ã  chaque ligne
resultat = matrice + vecteur
print("\\nMatrice + Vecteur (broadcasting):")
print(resultat)

# Exemple 2: Normalisation par colonne
donnees = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]], dtype=float)

# Calculer la moyenne de chaque colonne
moyennes = np.mean(donnees, axis=0)
print("\\nDonnÃ©es originales:")
print(donnees)
print("Moyennes par colonne:", moyennes)

# Centrer les donnÃ©es (broadcasting automatique)
donnees_centrees = donnees - moyennes
print("\\nDonnÃ©es centrÃ©es:")
print(donnees_centrees)
print("Nouvelles moyennes:", np.mean(donnees_centrees, axis=0))

# Exemple 3: OpÃ©ration avec scalaire
print("\\nMultiplication par scalaire (broadcasting):")
print(matrice * 2)

# Exemple 4: Broadcasting complexe
a = np.array([[1], [2], [3]])  # (3, 1)
b = np.array([10, 20])         # (2,)
print("\\nBroadcasting complexe:")
print("a (3x1):\\n", a)
print("b (2,):", b)
print("a + b (3x2):\\n", a + b)`,
          },
          {
            type: "code",
            title: "AlgÃ¨bre linÃ©aire avec NumPy",
            description:
              "NumPy implÃ©mente toutes les opÃ©rations d'algÃ¨bre linÃ©aire :",
            code: `import numpy as np

# CrÃ©ation de matrices
A = np.array([[1, 2], 
              [3, 4]])
B = np.array([[5, 6], 
              [7, 8]])
v = np.array([1, 2])

print("Matrice A:")
print(A)
print("\\nMatrice B:")
print(B)
print("\\nVecteur v:", v)

# Produit matriciel (@ ou np.dot)
produit = A @ B  # Ã‰quivalent Ã  np.dot(A, B)
print("\\nProduit matriciel A @ B:")
print(produit)

# Produit matrice-vecteur
Av = A @ v
print("\\nProduit A @ v:", Av)

# TransposÃ©e
print("\\nTransposÃ©e de A:")
print(A.T)

# DÃ©terminant
det_A = np.linalg.det(A)
print("\\nDÃ©terminant de A:", det_A)

# Inverse
inv_A = np.linalg.inv(A)
print("\\nInverse de A:")
print(inv_A)

# VÃ©rification: A @ inv(A) = I
verification = A @ inv_A
print("\\nVÃ©rification A @ inv(A):")
print(verification)

# Valeurs et vecteurs propres
valeurs_propres, vecteurs_propres = np.linalg.eig(A)
print("\\nValeurs propres:", valeurs_propres)
print("Vecteurs propres:")
print(vecteurs_propres)

# Norme d'un vecteur
norme = np.linalg.norm(v)
print("\\nNorme du vecteur v:", norme)`,
          },
          {
            type: "exemple",
            icon: "ğŸ’»",
            title: "Exercice pratique : traitement d'image",
            content: `
                        <p><strong>ğŸ¯ Exercice Ã  rÃ©soudre :</strong></p>
                        <p>Simulons le traitement d'une image en niveaux de gris (matrice de pixels) :</p>
                        
                        <p><strong>ğŸ“ TÃ¢ches :</strong></p>
                        <ol>
                            <li>CrÃ©er une "image" 5x5 avec des valeurs alÃ©atoires entre 0 et 255</li>
                            <li>Appliquer un filtre de flou (moyenne des voisins)</li>
                            <li>Augmenter la luminositÃ© de 20%</li>
                            <li>CrÃ©er un masque pour les pixels sombres (< 100)</li>
                        </ol>
                        
                        <p><strong>âœ… Solution :</strong></p>
                        <button class="btn btn-copy" onclick="toggleSolution('numpy-exercise-solution')" style="margin-bottom: 1rem;">
                            ğŸ‘ï¸ Voir la solution
                        </button>
                        <div id="numpy-exercise-solution" style="display: none;">
                        <pre><code>import numpy as np

# 1. CrÃ©er une image 5x5
np.random.seed(42)  # Pour la reproductibilitÃ©
image = np.random.randint(0, 256, (5, 5))
print("Image originale:")
print(image)

# 2. Filtre de flou simple (moyenne 3x3)
def appliquer_flou(img):
    # CrÃ©er une image avec padding pour gÃ©rer les bords
    padded = np.pad(img, 1, mode='edge')
    flou = np.zeros_like(img)
    
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            # Moyenne des 9 pixels voisins
            region = padded[i:i+3, j:j+3]
            flou[i, j] = np.mean(region)
    
    return flou.astype(int)

image_flou = appliquer_flou(image)
print("\\nImage avec flou:")
print(image_flou)

# 3. Augmenter la luminositÃ©
luminosite = np.clip(image * 1.2, 0, 255).astype(int)
print("\\nImage plus lumineuse (+20%):")
print(luminosite)

# 4. Masque pour pixels sombres
masque_sombre = image < 100
pixels_sombres = np.sum(masque_sombre)

print("\\nMasque pixels sombres (< 100):")
print(masque_sombre.astype(int))
print(f"Nombre de pixels sombres: {pixels_sombres}")

# Bonus: statistiques de l'image
print("\\nStatistiques de l'image:")
print(f"LuminositÃ© moyenne: {np.mean(image):.1f}")
print(f"Contraste (Ã©cart-type): {np.std(image):.1f}")
print(f"Pixel le plus sombre: {np.min(image)}")
print(f"Pixel le plus clair: {np.max(image)}")
</code></pre>
                        </div>
                    `,
          },
          {
            type: "warning",
            icon: "âš ï¸",
            title: "Optimisations et bonnes pratiques",
            content: `
                        <p><strong>ğŸš€ Optimisations NumPy :</strong></p>
                        <ul>
                            <li>âš¡ <strong>Vectorisation</strong> : Ã©viter les boucles Python</li>
                            <li>ğŸ“Š <strong>Broadcasting</strong> : utiliser les opÃ©rations automatiques</li>
                            <li>ğŸ’¾ <strong>Views vs Copies</strong> : attention aux modifications</li>
                            <li>ğŸ¯ <strong>Dtype appropriÃ©</strong> : int32 vs float64 selon les besoins</li>
                        </ul>
                        
                        <p><strong>âš ï¸ PiÃ¨ges Ã  Ã©viter :</strong></p>
                        <ul>
                            <li>ğŸŒ <strong>Boucles Python</strong> sur des arrays NumPy</li>
                            <li>ğŸ“ <strong>Copies inutiles</strong> : utiliser les views quand possible</li>
                            <li>ğŸ”¢ <strong>Mauvais dtype</strong> : float64 par dÃ©faut peut Ãªtre excessif</li>
                            <li>ğŸ“ <strong>Broadcasting non intentionnel</strong> : vÃ©rifier les shapes</li>
                        </ul>
                        
                        <p><strong>ğŸ’¡ RÃ¨gle d'or :</strong> Si vous Ã©crivez une boucle for sur un array NumPy, il y a probablement une meilleure faÃ§on vectorisÃ©e !</p>
                        
                        <p><strong>ğŸ”® Prochaine Ã©tape :</strong> Pandas pour la manipulation de donnÃ©es structurÃ©es !</p>
                    `,
          },
        ],
        quiz: {
          question:
            "ğŸ¤” Quelle est la principale diffÃ©rence entre une liste Python et un array NumPy ?",
          options: [
            "A) Les arrays NumPy peuvent contenir plus d'Ã©lÃ©ments",
            "B) Les arrays NumPy sont plus rapides pour les calculs numÃ©riques",
            "C) Les listes Python sont plus prÃ©cises",
            "D) Il n'y a pas de diffÃ©rence significative",
          ],
          correct: 1,
          explanation:
            "Les arrays NumPy sont optimisÃ©s pour les calculs numÃ©riques et peuvent Ãªtre jusqu'Ã  100x plus rapides que les listes Python grÃ¢ce Ã  leur implÃ©mentation en C et aux opÃ©rations vectorisÃ©es.",
        },
        prevModule: "basics.html",
        nextModule: "pandas.html",
      };

      // Initialiser le module
      document.addEventListener("DOMContentLoaded", function () {
        initializeModule(moduleConfig);
      });
    </script>
  </body>
</html>
