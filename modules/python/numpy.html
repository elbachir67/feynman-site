<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>NumPy | IA4Ndada</title>

    <!-- Pyodide pour Python dans le navigateur -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>

    <link rel="stylesheet" href="../../styles/module.css" />
  </head>
  <body>
    <!-- Navigation -->
    <nav class="nav">
      <div class="nav-container">
        <div class="nav-breadcrumb">
          <a href="../../index.html">üè† Accueil</a>
          <span>‚Ä∫</span>
          <span>üíª Python</span>
          <span>‚Ä∫</span>
          <span>NumPy</span>
        </div>
        <div class="progress-indicator">
          <span id="progress-text">Progression: 0%</span>
          <div class="progress-bar">
            <div
              class="progress-fill"
              id="progress-fill"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>
    </nav>

    <!-- Contenu principal -->
    <div class="container">
      <h1>üî¢ NumPy : Calcul Num√©rique</h1>
      <p class="subtitle">Module 2.2 - Programmation pour l'IA</p>

      <!-- Objectifs -->
      <div class="objectives">
        <h2>üéØ Objectifs d'apprentissage</h2>
        <ul id="objectives-list">
          <!-- Les objectifs seront ajout√©s dynamiquement -->
        </ul>
      </div>

      <!-- Contenu du module -->
      <div id="module-content">
        <!-- Le contenu sera ajout√© dynamiquement -->
      </div>

      <!-- Quiz -->
      <div class="quiz" id="module-quiz" style="display: none">
        <div class="quiz-question" id="quiz-question"></div>
        <div class="quiz-options" id="quiz-options"></div>
        <div class="quiz-feedback" id="quiz-feedback"></div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint">
        <h3>üéâ Checkpoint - NumPy</h3>
        <p>
          F√©licitations ! Vous ma√Ætrisez maintenant NumPy pour les calculs
          num√©riques en IA.
        </p>
        <button
          class="checkpoint-btn"
          id="checkpoint-btn"
          onclick="completeCheckpoint()"
        >
          Marquer comme compl√©t√©
        </button>
      </div>

      <!-- Navigation entre modules -->
      <div class="module-nav">
        <a href="basics.html" class="nav-link" id="prev-link"
          >‚Üê Module pr√©c√©dent : Python Bases</a
        >
        <a href="pandas.html" class="nav-link" id="next-link"
          >Module suivant : Pandas ‚Üí</a
        >
      </div>
    </div>

    <script src="../../scripts/module-engine.js"></script>
    <script>
      // Configuration du module NumPy
      const moduleConfig = {
        id: "python-numpy",
        title: "NumPy : Calcul Num√©rique",
        category: "Python",
        objectives: [
          "Comprendre pourquoi NumPy est essentiel pour l'IA",
          "Cr√©er et manipuler des arrays NumPy efficacement",
          "Ma√Ætriser les op√©rations vectorielles et matricielles",
          "Appliquer NumPy aux probl√®mes concrets d'IA",
        ],
        content: [
          {
            type: "concept",
            icon: "üí°",
            title: "Pourquoi NumPy r√©volutionne l'IA ?",
            content: `
                        <p><strong>NumPy</strong> (Numerical Python) est la fondation de tout l'√©cosyst√®me IA en Python. Sans NumPy, pas de Pandas, pas de scikit-learn, pas de TensorFlow !</p>
                        
                        <p><strong>üîë Probl√®me r√©solu :</strong></p>
                        <ul>
                            <li>üìä <strong>Listes Python</strong> : lentes pour les gros calculs</li>
                            <li>‚ö° <strong>Arrays NumPy</strong> : jusqu'√† 100x plus rapides !</li>
                        </ul>
                        
                        <p><strong>üöÄ Avantages NumPy :</strong></p>
                        <ul>
                            <li>‚ö° <strong>Performance</strong> : code optimis√© en C</li>
                            <li>üßÆ <strong>Vectorisation</strong> : op√©rations sur des arrays entiers</li>
                            <li>üìê <strong>Broadcasting</strong> : op√©rations entre arrays de tailles diff√©rentes</li>
                            <li>üîó <strong>Int√©gration</strong> : base de tout l'√©cosyst√®me scientifique</li>
                        </ul>
                        
                        <p><strong>ü§ñ Applications en IA :</strong></p>
                        <ul>
                            <li>üñºÔ∏è <strong>Images</strong> : matrices de pixels</li>
                            <li>üìä <strong>Datasets</strong> : tableaux de donn√©es</li>
                            <li>üß† <strong>R√©seaux de neurones</strong> : matrices de poids</li>
                            <li>üìà <strong>Calculs math√©matiques</strong> : alg√®bre lin√©aire rapide</li>
                        </ul>
                    `,
          },
          {
            type: "intuition",
            icon: "üß†",
            title: "Liste Python vs Array NumPy",
            content: `
                        <p>Imaginez que vous devez <strong>additionner 1 million de nombres</strong> :</p>
                        
                        <p><strong>üêå Avec des listes Python :</strong></p>
                        <ul>
                            <li>Python parcourt chaque √©l√©ment un par un</li>
                            <li>V√©rifie le type de chaque nombre</li>
                            <li>Fait l'addition en Python pur</li>
                            <li><strong>R√©sultat :</strong> 1 seconde ‚è±Ô∏è</li>
                        </ul>
                        
                        <p><strong>‚ö° Avec des arrays NumPy :</strong></p>
                        <ul>
                            <li>NumPy sait que tous les √©l√©ments sont des nombres</li>
                            <li>Utilise du code C optimis√©</li>
                            <li>Traite plusieurs √©l√©ments simultan√©ment</li>
                            <li><strong>R√©sultat :</strong> 0.01 seconde ‚ö°</li>
                        </ul>
                        
                        <p><strong>üí° Analogie :</strong></p>
                        <p>C'est comme la diff√©rence entre :</p>
                        <ul>
                            <li>üö∂ <strong>Marcher</strong> (listes Python) : flexible mais lent</li>
                            <li>üöÑ <strong>TGV</strong> (arrays NumPy) : rapide sur des rails optimis√©s</li>
                        </ul>
                    `,
          },
          {
            type: "code",
            title: "Cr√©ation d'arrays NumPy",
            description:
              "D√©couvrons les diff√©rentes fa√ßons de cr√©er des arrays :",
            code: `import numpy as np

# Cr√©ation √† partir d'une liste
liste_python = [1, 2, 3, 4, 5]
array_numpy = np.array(liste_python)

print("Liste Python:", liste_python)
print("Array NumPy:", array_numpy)
print("Type:", type(array_numpy))

# Arrays 2D (matrices)
matrice = np.array([[1, 2, 3], 
                    [4, 5, 6]])
print("\\nMatrice 2D:")
print(matrice)
print("Forme (shape):", matrice.shape)  # (lignes, colonnes)

# Cr√©ation d'arrays sp√©ciaux
zeros = np.zeros(5)  # Array de z√©ros
ones = np.ones((3, 4))  # Matrice de uns
identite = np.eye(3)  # Matrice identit√©
aleatoire = np.random.random((2, 3))  # Nombres al√©atoires

print("\\nArrays sp√©ciaux:")
print("Z√©ros:", zeros)
print("Ones:\\n", ones)
print("Identit√©:\\n", identite)
print("Al√©atoire:\\n", aleatoire)

# S√©quences
sequence = np.arange(0, 10, 2)  # De 0 √† 10, pas de 2
lineaire = np.linspace(0, 1, 5)  # 5 points entre 0 et 1

print("\\nS√©quences:")
print("Arange:", sequence)
print("Linspace:", lineaire)`,
          },
          {
            type: "code",
            title: "Op√©rations vectorielles",
            description:
              "La puissance de NumPy : op√©rations sur des arrays entiers :",
            code: `import numpy as np

# Cr√©ation d'arrays
a = np.array([1, 2, 3, 4, 5])
b = np.array([10, 20, 30, 40, 50])

print("Array a:", a)
print("Array b:", b)

# Op√©rations √©l√©ment par √©l√©ment (vectoris√©es)
addition = a + b
multiplication = a * b
puissance = a ** 2
racine = np.sqrt(a)

print("\\nOp√©rations vectoris√©es:")
print("a + b =", addition)
print("a * b =", multiplication)
print("a¬≤ =", puissance)
print("‚àöa =", racine)

# Op√©rations avec des scalaires
scalaire = a + 10  # Ajoute 10 √† chaque √©l√©ment
print("\\na + 10 =", scalaire)

# Fonctions math√©matiques
angles = np.array([0, np.pi/4, np.pi/2, np.pi])
sinus = np.sin(angles)
cosinus = np.cos(angles)

print("\\nFonctions trigonom√©triques:")
print("Angles:", angles)
print("Sin:", sinus)
print("Cos:", cosinus)

# Statistiques
donnees = np.array([12, 15, 18, 14, 16, 13, 17])
print("\\nStatistiques:")
print("Donn√©es:", donnees)
print("Moyenne:", np.mean(donnees))
print("M√©diane:", np.median(donnees))
print("√âcart-type:", np.std(donnees))
print("Min/Max:", np.min(donnees), "/", np.max(donnees))`,
          },
          {
            type: "code",
            title: "Indexation et slicing avanc√©s",
            description: "Acc√©der et modifier les donn√©es efficacement :",
            code: `import numpy as np

# Array 2D pour les exemples
matrice = np.array([[1,  2,  3,  4],
                    [5,  6,  7,  8],
                    [9, 10, 11, 12]])

print("Matrice originale:")
print(matrice)

# Indexation de base
print("\\nIndexation:")
print("√âl√©ment [0,0]:", matrice[0, 0])
print("√âl√©ment [1,2]:", matrice[1, 2])
print("Derni√®re ligne:", matrice[-1])
print("Derni√®re colonne:", matrice[:, -1])

# Slicing
print("\\nSlicing:")
print("2 premi√®res lignes:\\n", matrice[:2])
print("2 derni√®res colonnes:\\n", matrice[:, -2:])
print("Sous-matrice [1:3, 1:3]:\\n", matrice[1:3, 1:3])

# Indexation bool√©enne (tr√®s puissant !)
condition = matrice > 6
print("\\nIndexation bool√©enne:")
print("√âl√©ments > 6:", condition)
print("Valeurs > 6:", matrice[condition])

# Modification avec indexation bool√©enne
matrice_copie = matrice.copy()
matrice_copie[matrice_copie > 8] = 99
print("\\nApr√®s modification (>8 ‚Üí 99):")
print(matrice_copie)

# Indexation avec des arrays
indices_lignes = np.array([0, 2])
indices_colonnes = np.array([1, 3])
print("\\nIndexation avec arrays:")
print("Lignes 0 et 2:", matrice[indices_lignes])
print("√âl√©ments [0,1] et [2,3]:", matrice[indices_lignes, indices_colonnes])`,
          },
          {
            type: "mathematique",
            icon: "‚àë",
            title: "Broadcasting : la magie NumPy",
            content: `
                        <p>Le <strong>broadcasting</strong> permet d'effectuer des op√©rations entre arrays de tailles diff√©rentes. C'est l'une des fonctionnalit√©s les plus puissantes de NumPy !</p>
                        
                        <p><strong>üîë R√®gles du broadcasting :</strong></p>
                        <ol>
                            <li>NumPy compare les dimensions de droite √† gauche</li>
                            <li>Les dimensions sont compatibles si elles sont √©gales ou si l'une vaut 1</li>
                            <li>Les dimensions manquantes sont consid√©r√©es comme 1</li>
                        </ol>
                        
                        <p><strong>üìê Exemples de compatibilit√© :</strong></p>
                        <ul style="list-style: none; padding-left: 0">
                            <li><strong>‚Ä¢ (3, 4) + (4,)</strong> ‚Üí ‚úÖ Compatible</li>
                            <li><strong>‚Ä¢ (3, 4) + (3, 1)</strong> ‚Üí ‚úÖ Compatible</li>
                            <li><strong>‚Ä¢ (3, 4) + (2, 4)</strong> ‚Üí ‚ùå Incompatible</li>
                        </ul>
                        
                        <p><strong>üéØ Applications pratiques :</strong></p>
                        <ul>
                            <li>üìä <strong>Normalisation</strong> : soustraire la moyenne de chaque colonne</li>
                            <li>üñºÔ∏è <strong>Traitement d'images</strong> : appliquer un filtre √† tous les pixels</li>
                            <li>üß† <strong>R√©seaux de neurones</strong> : ajouter un biais √† chaque neurone</li>
                        </ul>
                        
                        <p><strong>üí° Avantage :</strong> Pas besoin de boucles explicites, NumPy g√®re tout automatiquement !</p>
                    `,
          },
          {
            type: "code",
            title: "Broadcasting en action",
            description: "Voyons le broadcasting √† l'≈ìuvre :",
            code: `import numpy as np

# Exemple 1: Array 2D + Array 1D
matrice = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]])

vecteur = np.array([10, 20, 30])

print("Matrice (3x3):")
print(matrice)
print("\\nVecteur (3,):")
print(vecteur)

# Broadcasting: ajoute le vecteur √† chaque ligne
resultat = matrice + vecteur
print("\\nMatrice + Vecteur (broadcasting):")
print(resultat)

# Exemple 2: Normalisation par colonne
donnees = np.array([[1, 2, 3],
                    [4, 5, 6],
                    [7, 8, 9]], dtype=float)

# Calculer la moyenne de chaque colonne
moyennes = np.mean(donnees, axis=0)
print("\\nDonn√©es originales:")
print(donnees)
print("Moyennes par colonne:", moyennes)

# Centrer les donn√©es (broadcasting automatique)
donnees_centrees = donnees - moyennes
print("\\nDonn√©es centr√©es:")
print(donnees_centrees)
print("Nouvelles moyennes:", np.mean(donnees_centrees, axis=0))

# Exemple 3: Op√©ration avec scalaire
print("\\nMultiplication par scalaire (broadcasting):")
print(matrice * 2)

# Exemple 4: Broadcasting complexe
a = np.array([[1], [2], [3]])  # (3, 1)
b = np.array([10, 20])         # (2,)
print("\\nBroadcasting complexe:")
print("a (3x1):\\n", a)
print("b (2,):", b)
print("a + b (3x2):\\n", a + b)`,
          },
          {
            type: "code",
            title: "Alg√®bre lin√©aire avec NumPy",
            description:
              "NumPy impl√©mente toutes les op√©rations d'alg√®bre lin√©aire :",
            code: `import numpy as np

# Cr√©ation de matrices
A = np.array([[1, 2], 
              [3, 4]])
B = np.array([[5, 6], 
              [7, 8]])
v = np.array([1, 2])

print("Matrice A:")
print(A)
print("\\nMatrice B:")
print(B)
print("\\nVecteur v:", v)

# Produit matriciel (@ ou np.dot)
produit = A @ B  # √âquivalent √† np.dot(A, B)
print("\\nProduit matriciel A @ B:")
print(produit)

# Produit matrice-vecteur
Av = A @ v
print("\\nProduit A @ v:", Av)

# Transpos√©e
print("\\nTranspos√©e de A:")
print(A.T)

# D√©terminant
det_A = np.linalg.det(A)
print("\\nD√©terminant de A:", det_A)

# Inverse
inv_A = np.linalg.inv(A)
print("\\nInverse de A:")
print(inv_A)

# V√©rification: A @ inv(A) = I
verification = A @ inv_A
print("\\nV√©rification A @ inv(A):")
print(verification)

# Valeurs et vecteurs propres
valeurs_propres, vecteurs_propres = np.linalg.eig(A)
print("\\nValeurs propres:", valeurs_propres)
print("Vecteurs propres:")
print(vecteurs_propres)

# Norme d'un vecteur
norme = np.linalg.norm(v)
print("\\nNorme du vecteur v:", norme)`,
          },
          {
            type: "exemple",
            icon: "üíª",
            title: "Exercice pratique : traitement d'image",
            content: `
                        <p><strong>üéØ Exercice √† r√©soudre :</strong></p>
                        <p>Simulons le traitement d'une image en niveaux de gris (matrice de pixels) :</p>
                        
                        <p><strong>üìù T√¢ches :</strong></p>
                        <ol>
                            <li>Cr√©er une "image" 5x5 avec des valeurs al√©atoires entre 0 et 255</li>
                            <li>Appliquer un filtre de flou (moyenne des voisins)</li>
                            <li>Augmenter la luminosit√© de 20%</li>
                            <li>Cr√©er un masque pour les pixels sombres (< 100)</li>
                        </ol>
                        
                        <p><strong>‚úÖ Solution :</strong></p>
                        <button class="btn btn-copy" onclick="toggleSolution('numpy-exercise-solution')" style="margin-bottom: 1rem;">
                            üëÅÔ∏è Voir la solution
                        </button>
                        <div id="numpy-exercise-solution" style="display: none;">
                        <pre><code>import numpy as np

# 1. Cr√©er une image 5x5
np.random.seed(42)  # Pour la reproductibilit√©
image = np.random.randint(0, 256, (5, 5))
print("Image originale:")
print(image)

# 2. Filtre de flou simple (moyenne 3x3)
def appliquer_flou(img):
    # Cr√©er une image avec padding pour g√©rer les bords
    padded = np.pad(img, 1, mode='edge')
    flou = np.zeros_like(img)
    
    for i in range(img.shape[0]):
        for j in range(img.shape[1]):
            # Moyenne des 9 pixels voisins
            region = padded[i:i+3, j:j+3]
            flou[i, j] = np.mean(region)
    
    return flou.astype(int)

image_flou = appliquer_flou(image)
print("\\nImage avec flou:")
print(image_flou)

# 3. Augmenter la luminosit√©
luminosite = np.clip(image * 1.2, 0, 255).astype(int)
print("\\nImage plus lumineuse (+20%):")
print(luminosite)

# 4. Masque pour pixels sombres
masque_sombre = image < 100
pixels_sombres = np.sum(masque_sombre)

print("\\nMasque pixels sombres (< 100):")
print(masque_sombre.astype(int))
print(f"Nombre de pixels sombres: {pixels_sombres}")

# Bonus: statistiques de l'image
print("\\nStatistiques de l'image:")
print(f"Luminosit√© moyenne: {np.mean(image):.1f}")
print(f"Contraste (√©cart-type): {np.std(image):.1f}")
print(f"Pixel le plus sombre: {np.min(image)}")
print(f"Pixel le plus clair: {np.max(image)}")
</code></pre>
                        </div>
                    `,
          },
          {
            type: "warning",
            icon: "‚ö†Ô∏è",
            title: "Optimisations et bonnes pratiques",
            content: `
                        <p><strong>üöÄ Optimisations NumPy :</strong></p>
                        <ul>
                            <li>‚ö° <strong>Vectorisation</strong> : √©viter les boucles Python</li>
                            <li>üìä <strong>Broadcasting</strong> : utiliser les op√©rations automatiques</li>
                            <li>üíæ <strong>Views vs Copies</strong> : attention aux modifications</li>
                            <li>üéØ <strong>Dtype appropri√©</strong> : int32 vs float64 selon les besoins</li>
                        </ul>
                        
                        <p><strong>‚ö†Ô∏è Pi√®ges √† √©viter :</strong></p>
                        <ul>
                            <li>üêå <strong>Boucles Python</strong> sur des arrays NumPy</li>
                            <li>üìù <strong>Copies inutiles</strong> : utiliser les views quand possible</li>
                            <li>üî¢ <strong>Mauvais dtype</strong> : float64 par d√©faut peut √™tre excessif</li>
                            <li>üìê <strong>Broadcasting non intentionnel</strong> : v√©rifier les shapes</li>
                        </ul>
                        
                        <p><strong>üí° R√®gle d'or :</strong> Si vous √©crivez une boucle for sur un array NumPy, il y a probablement une meilleure fa√ßon vectoris√©e !</p>
                        
                        <p><strong>üîÆ Prochaine √©tape :</strong> Pandas pour la manipulation de donn√©es structur√©es !</p>
                    `,
          },
        ],
        quiz: {
          question:
            "ü§î Quelle est la principale diff√©rence entre une liste Python et un array NumPy ?",
          options: [
            "A) Les arrays NumPy peuvent contenir plus d'√©l√©ments",
            "B) Les arrays NumPy sont plus rapides pour les calculs num√©riques",
            "C) Les listes Python sont plus pr√©cises",
            "D) Il n'y a pas de diff√©rence significative",
          ],
          correct: 1,
          explanation:
            "Les arrays NumPy sont optimis√©s pour les calculs num√©riques et peuvent √™tre jusqu'√† 100x plus rapides que les listes Python gr√¢ce √† leur impl√©mentation en C et aux op√©rations vectoris√©es.",
        },
        prevModule: "basics.html",
        nextModule: "pandas.html",
      };

      // Initialiser le module
      document.addEventListener("DOMContentLoaded", function () {
        initializeModule(moduleConfig);
      });
    </script>
  </body>
</html>
