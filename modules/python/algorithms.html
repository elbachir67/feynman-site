<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithmes | IA4Ndada</title>

    <!-- Pyodide pour Python dans le navigateur -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>

    <link rel="stylesheet" href="../../styles/module.css" />
  </head>
  <body>
    <!-- Navigation -->
    <nav class="nav">
      <div class="nav-container">
        <div class="nav-breadcrumb">
          <a href="../../index.html">ğŸ  Accueil</a>
          <span>â€º</span>
          <span>ğŸ’» Python</span>
          <span>â€º</span>
          <span>Algorithmes</span>
        </div>
        <div class="progress-indicator">
          <span id="progress-text">Progression: 0%</span>
          <div class="progress-bar">
            <div
              class="progress-fill"
              id="progress-fill"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>
    </nav>

    <!-- Contenu principal -->
    <div class="container">
      <h1>âš™ï¸ Algorithmes : Logique et EfficacitÃ©</h1>
      <p class="subtitle">Module 2.5 - Programmation pour l'IA</p>

      <!-- Objectifs -->
      <div class="objectives">
        <h2>ğŸ¯ Objectifs d'apprentissage</h2>
        <ul id="objectives-list">
          <!-- Les objectifs seront ajoutÃ©s dynamiquement -->
        </ul>
      </div>

      <!-- Contenu du module -->
      <div id="module-content">
        <!-- Le contenu sera ajoutÃ© dynamiquement -->
      </div>

      <!-- Quiz -->
      <div class="quiz" id="module-quiz" style="display: none">
        <div class="quiz-question" id="quiz-question"></div>
        <div class="quiz-options" id="quiz-options"></div>
        <div class="quiz-feedback" id="quiz-feedback"></div>
      </div>

      <!-- Checkpoint -->
      <div class="checkpoint">
        <h3>ğŸ‰ Checkpoint - Algorithmes</h3>
        <p>
          FÃ©licitations ! Vous maÃ®trisez maintenant les algorithmes essentiels
          pour l'IA.
        </p>
        <button
          class="checkpoint-btn"
          id="checkpoint-btn"
          onclick="completeCheckpoint()"
        >
          Marquer comme complÃ©tÃ©
        </button>
      </div>

      <!-- Navigation entre modules -->
      <div class="module-nav">
        <a href="matplotlib.html" class="nav-link" id="prev-link"
          >â† Module prÃ©cÃ©dent : Matplotlib</a
        >
        <a href="../ml/introduction.html" class="nav-link" id="next-link"
          >Module suivant : Machine Learning â†’</a
        >
      </div>
    </div>

    <script src="../../scripts/module-engine.js"></script>
    <script>
      // Configuration du module Algorithmes
      const moduleConfig = {
        id: "python-algorithms",
        title: "Algorithmes : Logique et EfficacitÃ©",
        category: "Python",
        objectives: [
          "Comprendre pourquoi les algorithmes sont cruciaux en IA",
          "MaÃ®triser les algorithmes de tri et de recherche",
          "Analyser la complexitÃ© temporelle et spatiale",
          "ImplÃ©menter des structures de donnÃ©es efficaces",
        ],
        content: [
          {
            type: "concept",
            icon: "ğŸ’¡",
            title: "Pourquoi les algorithmes dominent l'IA ?",
            content: `
                        <p><strong>Les algorithmes</strong> sont le cÅ“ur battant de l'intelligence artificielle. Sans algorithmes efficaces, mÃªme les ordinateurs les plus puissants seraient inutiles !</p>
                        
                        <p><strong>ğŸ”‘ ProblÃ¨me concret :</strong></p>
                        <ul>
                            <li>ğŸ“Š <strong>Recherche naÃ¯ve</strong> : 1 million de donnÃ©es = 1 million d'opÃ©rations</li>
                            <li>âš¡ <strong>Recherche binaire</strong> : 1 million de donnÃ©es = 20 opÃ©rations !</li>
                        </ul>
                        
                        <p><strong>ğŸš€ Impact en IA :</strong></p>
                        <ul>
                            <li>ğŸ§  <strong>RÃ©seaux de neurones</strong> : algorithmes d'optimisation (Adam, SGD)</li>
                            <li>ğŸ” <strong>Recherche</strong> : Google utilise PageRank (algorithme de graphe)</li>
                            <li>ğŸ¯ <strong>Recommandations</strong> : algorithmes de filtrage collaboratif</li>
                            <li>ğŸ’¬ <strong>LLMs</strong> : algorithmes d'attention et transformers</li>
                        </ul>
                        
                        <p><strong>ğŸ¤– Applications concrÃ¨tes :</strong></p>
                        <ul>
                            <li>ğŸ“± <strong>Tri intelligent</strong> : organiser 1 million de photos en secondes</li>
                            <li>ğŸš— <strong>Navigation GPS</strong> : trouver le chemin optimal parmi des millions de routes</li>
                            <li>ğŸ›’ <strong>E-commerce</strong> : recommander les bons produits parmi des millions</li>
                            <li>ğŸ¥ <strong>Diagnostic mÃ©dical</strong> : analyser des milliers de symptÃ´mes rapidement</li>
                        </ul>
                    `,
          },
          {
            type: "intuition",
            icon: "ğŸ§ ",
            title: "L'analogie du marchÃ© de Sandaga",
            content: `
                        <p>Imaginez que vous cherchez <strong>un tissu spÃ©cifique au marchÃ© de Sandaga</strong> Ã  Dakar :</p>
                        
                        <p><strong>ğŸŒ Approche naÃ¯ve (recherche linÃ©aire) :</strong></p>
                        <ul>
                            <li>Vous visitez <strong>chaque boutique une par une</strong></li>
                            <li>1000 boutiques = 1000 visites dans le pire cas</li>
                            <li>Temps : <strong>toute la journÃ©e</strong> â°</li>
                        </ul>
                        
                        <p><strong>âš¡ Approche intelligente (recherche organisÃ©e) :</strong></p>
                        <ul>
                            <li>Vous demandez au <strong>chef de secteur</strong> qui connaÃ®t l'organisation</li>
                            <li>Il vous dirige vers la <strong>zone textile</strong></li>
                            <li>Puis vers le <strong>sous-secteur</strong> de votre tissu</li>
                            <li>Temps : <strong>15 minutes</strong> âš¡</li>
                        </ul>
                        
                        <p><strong>ğŸ’¡ C'est exactement la diffÃ©rence entre :</strong></p>
                        <ul>
                            <li>ğŸŒ <strong>Algorithme naÃ¯f</strong> : force brute, lent mais sÃ»r</li>
                            <li>ğŸ§  <strong>Algorithme intelligent</strong> : structure, rapide et efficace</li>
                        </ul>
                        
                        <p><strong>ğŸ¯ En IA, cette diffÃ©rence peut Ãªtre :</strong></p>
                        <ul>
                            <li>â° <strong>1 heure vs 1 seconde</strong> pour traiter des donnÃ©es</li>
                            <li>ğŸ’° <strong>1000â‚¬ vs 1â‚¬</strong> de coÃ»t de calcul cloud</li>
                            <li>ğŸ”‹ <strong>Batterie vide vs 1% consommÃ©</strong> sur mobile</li>
                        </ul>
                    `,
          },
          {
            type: "code",
            title: "Recherche linÃ©aire : mÃ©thode de base",
            description: "Cherchons un Ã©tudiant dans une liste de l'UCAD :",
            code: `# Base de donnÃ©es Ã©tudiants UCAD
etudiants_ucad = [
    "Aminata Diallo", "Moussa Sow", "Fatou Ba", "Ibrahima Fall",
    "Aissatou Ndiaye", "Ousmane Diouf", "Marieme Sarr", "Cheikh Sy",
    "Khady Faye", "Mamadou Kane", "Ndeye Diop", "Alioune Cisse"
]

def recherche_lineaire(liste, cible):
    """Recherche linÃ©aire : vÃ©rifie chaque Ã©lÃ©ment un par un"""
    comparaisons = 0
    
    for i, etudiant in enumerate(liste):
        comparaisons += 1
        print(f"VÃ©rification {comparaisons}: {etudiant}")
        
        if etudiant == cible:
            return i, comparaisons
    
    return -1, comparaisons

# Test de recherche
nom_recherche = "Cheikh Sy"
print(f"ğŸ” Recherche de: {nom_recherche}")
print(f"ğŸ“š Dans une liste de {len(etudiants_ucad)} Ã©tudiants UCAD")
print()

position, nb_comparaisons = recherche_lineaire(etudiants_ucad, nom_recherche)

if position != -1:
    print(f"âœ… TrouvÃ© Ã  la position {position}")
else:
    print("âŒ Ã‰tudiant non trouvÃ©")
    
print(f"ğŸ“Š Nombre de comparaisons: {nb_comparaisons}")`,
          },
          {
            type: "code",
            title: "Recherche binaire : mÃ©thode optimisÃ©e",
            description: "Recherche plus efficace sur une liste triÃ©e :",
            code: `# Liste triÃ©e alphabÃ©tiquement
etudiants_tries = sorted(etudiants_ucad)
print("ğŸ“‹ Liste triÃ©e:", etudiants_tries)
print()

def recherche_binaire(liste, cible):
    """Recherche binaire : divise la liste en deux Ã  chaque Ã©tape"""
    gauche, droite = 0, len(liste) - 1
    comparaisons = 0
    
    while gauche <= droite:
        comparaisons += 1
        milieu = (gauche + droite) // 2
        element_milieu = liste[milieu]
        
        print(f"Ã‰tape {comparaisons}: VÃ©rification de '{element_milieu}' (position {milieu})")
        
        if element_milieu == cible:
            return milieu, comparaisons
        elif element_milieu < cible:
            print(f"  â†’ '{cible}' est aprÃ¨s '{element_milieu}', chercher Ã  droite")
            gauche = milieu + 1
        else:
            print(f"  â†’ '{cible}' est avant '{element_milieu}', chercher Ã  gauche")
            droite = milieu - 1
    
    return -1, comparaisons

# Test de recherche binaire
print(f"ğŸ” Recherche binaire de: {nom_recherche}")
position, nb_comparaisons = recherche_binaire(etudiants_tries, nom_recherche)

if position != -1:
    print(f"âœ… TrouvÃ© Ã  la position {position}")
else:
    print("âŒ Ã‰tudiant non trouvÃ©")
    
print(f"ğŸ“Š Nombre de comparaisons: {nb_comparaisons}")
print(f"ğŸš€ Gain: {len(etudiants_ucad) - nb_comparaisons} comparaisons Ã©vitÃ©es!")`,
          },
          {
            type: "code",
            title: "Tri Ã  bulles : algorithme simple",
            description:
              "Trions les notes d'Ã©tudiants avec l'algorithme Ã  bulles :",
            code: `# Notes d'Ã©tudiants en IA (sur 20)
notes_ia = [12.5, 8.0, 16.5, 14.0, 9.5, 18.0, 11.0, 15.5, 13.0, 7.5]
etudiants_notes = [
    "Aminata", "Moussa", "Fatou", "Ibrahima", "Aissatou",
    "Ousmane", "Marieme", "Cheikh", "Khady", "Mamadou"
]

print("ğŸ“Š Notes initiales:")
for i, (etudiant, note) in enumerate(zip(etudiants_notes, notes_ia)):
    print(f"{i+1:2d}. {etudiant:10s}: {note:4.1f}/20")
print()

def tri_bulles(notes, noms):
    """Tri Ã  bulles : compare les Ã©lÃ©ments adjacents"""
    n = len(notes)
    notes_copie = notes.copy()
    noms_copie = noms.copy()
    comparaisons = 0
    echanges = 0
    
    for i in range(n):
        for j in range(0, n - i - 1):
            comparaisons += 1
            
            # Si l'Ã©lÃ©ment actuel est plus grand que le suivant
            if notes_copie[j] > notes_copie[j + 1]:
                # Ã‰changer les notes et les noms
                notes_copie[j], notes_copie[j + 1] = notes_copie[j + 1], notes_copie[j]
                noms_copie[j], noms_copie[j + 1] = noms_copie[j + 1], noms_copie[j]
                echanges += 1
                
                print(f"Ã‰change: {noms_copie[j]} ({notes_copie[j]}) â†” {noms_copie[j+1]} ({notes_copie[j+1]})")
    
    return notes_copie, noms_copie, comparaisons, echanges

notes_triees, noms_tries, comp, ech = tri_bulles(notes_ia, etudiants_notes)

print(f"\nğŸ“ˆ RÃ©sultat du tri (ordre croissant):")
for i, (etudiant, note) in enumerate(zip(noms_tries, notes_triees)):
    print(f"{i+1:2d}. {etudiant:10s}: {note:4.1f}/20")

print(f"\nğŸ“Š Statistiques:")
print(f"Comparaisons: {comp}")
print(f"Ã‰changes: {ech}")`,
          },
          {
            type: "code",
            title: "Structures de donnÃ©es : Pile (Stack)",
            description:
              "ImplÃ©mentons une pile pour gÃ©rer l'historique de navigation :",
            code: `class PileNavigation:
    """Pile pour gÃ©rer l'historique de navigation web"""
    
    def __init__(self):
        self.pages = []
    
    def visiter_page(self, url):
        """Ajouter une nouvelle page (push)"""
        self.pages.append(url)
        print(f"ğŸ“„ Visite: {url}")
    
    def page_precedente(self):
        """Retourner Ã  la page prÃ©cÃ©dente (pop)"""
        if len(self.pages) > 1:
            page_actuelle = self.pages.pop()
            page_precedente = self.pages[-1]
            print(f"â¬…ï¸ Retour de '{page_actuelle}' vers '{page_precedente}'")
            return page_precedente
        else:
            print("âŒ Aucune page prÃ©cÃ©dente")
            return None
    
    def page_actuelle(self):
        """Obtenir la page actuelle (peek)"""
        if self.pages:
            return self.pages[-1]
        return None
    
    def historique(self):
        """Afficher tout l'historique"""
        print("ğŸ“š Historique de navigation:")
        for i, page in enumerate(self.pages):
            marqueur = "ğŸ‘‰" if i == len(self.pages) - 1 else "  "
            print(f"{marqueur} {i+1}. {page}")

# Simulation de navigation sur des sites sÃ©nÃ©galais
nav = PileNavigation()

print("ğŸŒ SIMULATION NAVIGATION WEB SÃ‰NÃ‰GAL")
print("=" * 40)

# Navigation
nav.visiter_page("www.seneweb.com")
nav.visiter_page("www.dakaractu.com") 
nav.visiter_page("www.leral.net")
nav.visiter_page("www.xibar.net")

print(f"\nğŸ“ Page actuelle: {nav.page_actuelle()}")
nav.historique()

print(f"\nâ¬…ï¸ NAVIGATION ARRIÃˆRE:")
nav.page_precedente()
nav.page_precedente()

print(f"\nğŸ“ Page actuelle: {nav.page_actuelle()}")`,
          },
          {
            type: "code",
            title: "Structures de donnÃ©es : File (Queue)",
            description:
              "ImplÃ©mentons une file pour gÃ©rer les commandes d'un restaurant :",
            code: `from collections import deque

class FileCommandes:
    """File pour gÃ©rer les commandes d'un restaurant sÃ©nÃ©galais"""
    
    def __init__(self, nom_restaurant):
        self.commandes = deque()
        self.nom_restaurant = nom_restaurant
        self.numero_commande = 1
    
    def nouvelle_commande(self, client, plat):
        """Ajouter une nouvelle commande (enqueue)"""
        commande = {
            'numero': self.numero_commande,
            'client': client,
            'plat': plat,
            'statut': 'En attente'
        }
        self.commandes.append(commande)
        print(f"ğŸ½ï¸ Commande #{self.numero_commande}: {client} - {plat}")
        self.numero_commande += 1
    
    def servir_commande(self):
        """Servir la premiÃ¨re commande (dequeue)"""
        if self.commandes:
            commande = self.commandes.popleft()
            commande['statut'] = 'Servie'
            print(f"âœ… Servi: Commande #{commande['numero']} - {commande['client']}")
            return commande
        else:
            print("âŒ Aucune commande en attente")
            return None
    
    def afficher_file(self):
        """Afficher toutes les commandes en attente"""
        if not self.commandes:
            print("ğŸ“‹ Aucune commande en attente")
            return
        
        print(f"ğŸ“‹ FILE D'ATTENTE - {self.nom_restaurant}")
        print("-" * 40)
        for i, cmd in enumerate(self.commandes):
            position = "ğŸ‘‰ SUIVANT" if i == 0 else f"   #{i+1}"
            print(f"{position} - {cmd['client']}: {cmd['plat']}")

# Simulation restaurant sÃ©nÃ©galais
restaurant = FileCommandes("Chez Fatou - ThiÃ©boudienne")

print("ğŸ½ï¸ SIMULATION RESTAURANT SÃ‰NÃ‰GALAIS")
print("=" * 45)

# ArrivÃ©e des commandes
restaurant.nouvelle_commande("Aminata", "ThiÃ©boudienne rouge")
restaurant.nouvelle_commande("Moussa", "Yassa poulet")
restaurant.nouvelle_commande("Fatou", "MafÃ© bÅ“uf")
restaurant.nouvelle_commande("Ibrahima", "Thiou kandja")
restaurant.nouvelle_commande("Aissatou", "Caldou")

print()
restaurant.afficher_file()

print(f"\nğŸ³ SERVICE DES COMMANDES:")
restaurant.servir_commande()
restaurant.servir_commande()

print()
restaurant.afficher_file()`,
          },
          {
            type: "code",
            title: "Algorithme de recommandation simple",
            description:
              "CrÃ©ons un systÃ¨me de recommandation pour films sÃ©nÃ©galais :",
            code: `class RecommandationFilms:
    """SystÃ¨me de recommandation de films sÃ©nÃ©galais"""
    
    def __init__(self):
        # Base de films sÃ©nÃ©galais avec genres
        self.films = {
            "Adama": ["Drame", "Historique", "Animation"],
            "La Pirogue": ["Drame", "Social"],
            "Atlantique": ["Drame", "Fantastique"],
            "HyÃ¨nes": ["Drame", "ComÃ©die"],
            "MoolaadÃ©": ["Drame", "Social"],
            "Xala": ["ComÃ©die", "Satire"],
            "Ceddo": ["Historique", "Drame"],
            "Karmen GeÃ¯": ["Musical", "Drame"],
            "Guelwaar": ["Drame", "Politique"],
            "Faat KinÃ©": ["Drame", "FÃ©ministe"]
        }
        
        # Profils utilisateurs avec leurs prÃ©fÃ©rences
        self.utilisateurs = {}
    
    def ajouter_utilisateur(self, nom, films_aimes):
        """Ajouter un utilisateur avec ses films prÃ©fÃ©rÃ©s"""
        self.utilisateurs[nom] = films_aimes
        print(f"ğŸ‘¤ Utilisateur ajoutÃ©: {nom}")
        print(f"   Films aimÃ©s: {', '.join(films_aimes)}")
    
    def calculer_similarite(self, user1, user2):
        """Calculer la similaritÃ© entre deux utilisateurs"""
        films1 = set(self.utilisateurs[user1])
        films2 = set(self.utilisateurs[user2])
        
        # Coefficient de Jaccard: intersection / union
        intersection = len(films1.intersection(films2))
        union = len(films1.union(films2))
        
        return intersection / union if union > 0 else 0
    
    def recommander(self, utilisateur_cible):
        """Recommander des films Ã  un utilisateur"""
        if utilisateur_cible not in self.utilisateurs:
            print(f"âŒ Utilisateur '{utilisateur_cible}' non trouvÃ©")
            return []
        
        print(f"ğŸ¬ RECOMMANDATIONS POUR {utilisateur_cible}")
        print("=" * 40)
        
        # Trouver l'utilisateur le plus similaire
        meilleure_similarite = 0
        utilisateur_similaire = None
        
        for autre_user in self.utilisateurs:
            if autre_user != utilisateur_cible:
                sim = self.calculer_similarite(utilisateur_cible, autre_user)
                print(f"SimilaritÃ© avec {autre_user}: {sim:.2f}")
                
                if sim > meilleure_similarite:
                    meilleure_similarite = sim
                    utilisateur_similaire = autre_user
        
        if utilisateur_similaire:
            # Films du plus similaire que l'utilisateur cible n'a pas vus
            films_cible = set(self.utilisateurs[utilisateur_cible])
            films_similaire = set(self.utilisateurs[utilisateur_similaire])
            recommandations = films_similaire - films_cible
            
            print(f"\nâœ¨ Utilisateur le plus similaire: {utilisateur_similaire}")
            print(f"ğŸ“½ï¸ Films recommandÃ©s: {', '.join(recommandations)}")
            return list(recommandations)
        
        return []

# Test du systÃ¨me
systeme = RecommandationFilms()

# Ajout d'utilisateurs
systeme.ajouter_utilisateur("Aminata", ["Adama", "La Pirogue", "MoolaadÃ©"])
systeme.ajouter_utilisateur("Moussa", ["HyÃ¨nes", "Xala", "Guelwaar"])
systeme.ajouter_utilisateur("Fatou", ["Adama", "Atlantique", "Karmen GeÃ¯"])
systeme.ajouter_utilisateur("Ibrahima", ["La Pirogue", "Ceddo", "Faat KinÃ©"])

print()
# Recommandations pour Aminata
recommandations = systeme.recommander("Aminata")`,
          },
          {
            type: "code",
            title: "Optimisation : cache et mÃ©moÃ¯sation",
            description: "Optimisons les calculs avec la mÃ©moÃ¯sation :",
            code: `import time

# Fibonacci avec mÃ©moÃ¯sation (rapide)
cache_fibonacci = {}

def fibonacci_rapide(n):
    """Fibonacci avec cache - trÃ¨s efficace"""
    if n in cache_fibonacci:
        return cache_fibonacci[n]
    
    if n <= 1:
        cache_fibonacci[n] = n
        return n
    
    resultat = fibonacci_rapide(n-1) + fibonacci_rapide(n-2)
    cache_fibonacci[n] = resultat
    return resultat

# Application pratique: croissance dÃ©mographique du SÃ©nÃ©gal
def croissance_population_senegal(annee_base, population_base, taux_croissance, annees):
    """ModÃ¨le de croissance dÃ©mographique avec cache"""
    cache_population = {0: population_base}
    
    def calculer_population(n):
        if n in cache_population:
            return cache_population[n]
        
        if n == 0:
            return population_base
        
        pop_precedente = calculer_population(n-1)
        nouvelle_pop = pop_precedente * (1 + taux_croissance)
        cache_population[n] = nouvelle_pop
        return nouvelle_pop
    
    print(f"ğŸ“Š PROJECTION DÃ‰MOGRAPHIQUE SÃ‰NÃ‰GAL")
    print(f"AnnÃ©e de base: {annee_base}")
    print(f"Population de base: {population_base:,.0f} habitants")
    print(f"Taux de croissance: {taux_croissance*100:.1f}% par an")
    print("-" * 50)
    
    for i in range(0, annees + 1, 5):  # Tous les 5 ans
        population = calculer_population(i)
        annee = annee_base + i
        print(f"{annee}: {population:,.0f} habitants")
    
    return cache_population

# Test des performances Fibonacci
print("âš¡ TEST DE PERFORMANCE - FIBONACCI")
print("=" * 40)

n_test = 30
print(f"Calcul de Fibonacci({n_test}):")

# Version rapide
debut = time.time()
resultat_rapide = fibonacci_rapide(n_test)
temps_rapide = time.time() - debut
print(f"âš¡ Version optimisÃ©e: {resultat_rapide} en {temps_rapide:.6f}s")

print()

# Application dÃ©mographique
croissance_population_senegal(2024, 17_000_000, 0.025, 20)`,
          },
          {
            type: "warning",
            icon: "âš ï¸",
            title: "Algorithmes en IA : les fondations du futur",
            content: `
                        <p><strong>ğŸ§  Les algorithmes sont le DNA de l'IA moderne :</strong></p>
                        <ul>
                            <li>ğŸ¯ <strong>EfficacitÃ© cruciale</strong> : O(nÂ²) vs O(n log n) = diffÃ©rence entre 1h et 1 minute</li>
                            <li>ğŸ’° <strong>CoÃ»t Ã©conomique</strong> : algorithmes optimisÃ©s = millions d'euros Ã©conomisÃ©s</li>
                            <li>ğŸ”‹ <strong>Ã‰nergie</strong> : algorithmes efficaces = moins de consommation Ã©lectrique</li>
                            <li>ğŸ“± <strong>ExpÃ©rience utilisateur</strong> : rÃ©ponse instantanÃ©e vs attente frustrante</li>
                        </ul>
                        
                        <p><strong>ğŸ¤– Algorithmes fondamentaux en IA :</strong></p>
                        <ul>
                            <li>ğŸ” <strong>Recherche</strong> : BFS, DFS, A* pour navigation et jeux</li>
                            <li>ğŸ“Š <strong>Tri</strong> : QuickSort, MergeSort pour organiser les donnÃ©es</li>
                            <li>ğŸ§  <strong>Optimisation</strong> : Gradient descent, Adam pour entraÃ®ner les modÃ¨les</li>
                            <li>ğŸ¯ <strong>Recommandation</strong> : Filtrage collaboratif, similaritÃ© cosinus</li>
                            <li>ğŸ“ˆ <strong>Clustering</strong> : K-means, DBSCAN pour grouper les donnÃ©es</li>
                        </ul>
                        
                        <p><strong>ğŸ’¡ Point clÃ© :</strong> MaÃ®triser les algorithmes, c'est comprendre comment l'IA "pense" et optimise ses dÃ©cisions. C'est la diffÃ©rence entre utiliser l'IA et la crÃ©er !</p>
                        
                        <p><strong>ğŸ”® Prochaine Ã©tape :</strong> Machine Learning - oÃ¹ nous utiliserons ces algorithmes pour crÃ©er des systÃ¨mes intelligents !</p>
                    `,
          },
        ],
        quiz: {
          question:
            "ğŸ¤” Quelle est la complexitÃ© temporelle de la recherche binaire sur une liste triÃ©e de n Ã©lÃ©ments ?",
          options: [
            "A) O(n) - linÃ©aire",
            "B) O(log n) - logarithmique",
            "C) O(nÂ²) - quadratique",
            "D) O(1) - constante",
          ],
          correct: 1,
          explanation:
            "La recherche binaire a une complexitÃ© O(log n) car elle divise l'espace de recherche par 2 Ã  chaque Ã©tape. Pour 1 million d'Ã©lÃ©ments, elle ne nÃ©cessite que ~20 comparaisons au maximum !",
        },
        prevModule: "matplotlib.html",
        nextModule: "../ml/introduction.html",
      };

      // Initialiser le module
      document.addEventListener("DOMContentLoaded", function () {
        initializeModule(moduleConfig);
      });
    </script>
  </body>
</html>
